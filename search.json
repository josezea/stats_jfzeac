[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bienvenido al Diplomado de Métodos Estadísticos",
    "section": "",
    "text": "Este diplomado cubre los fundamentos de los métodos estadísticos para el análisis de datos, utilizando R y Python."
  },
  {
    "objectID": "index.html#sobre-este-diplomado",
    "href": "index.html#sobre-este-diplomado",
    "title": "Bienvenido al Diplomado de Métodos Estadísticos",
    "section": "",
    "text": "Este diplomado cubre los fundamentos de los métodos estadísticos para el análisis de datos, utilizando R y Python."
  },
  {
    "objectID": "index.html#contenido-del-curso",
    "href": "index.html#contenido-del-curso",
    "title": "Bienvenido al Diplomado de Métodos Estadísticos",
    "section": "Contenido del Curso",
    "text": "Contenido del Curso\n\nClase 1: Introducción y Frecuencias\nClase 2: (Próximamente)\nClase 3: (Próximamente)\n\nNavega usando el menú superior para acceder a los materiales de cada clase."
  },
  {
    "objectID": "clase1_diplomado.html",
    "href": "clase1_diplomado.html",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "Las siguientes notas son basadas en el libro Open Intro el cual será uno de los libros guias para este diplomado. La estadística puede ser definida como el estudio de cómo recolectar, analizar y sacar conclusiones de los datos [pág i]. Los datos mismos consisten en observaciones recolectadas de fuentes como notas de campo, encuestas y experimentos [pág i, pág 14]. Estadística es el estudio de cómo recolectar, analizar y sacar conclusiones de los datos [pág 1, pág 2].\n\n\nEl primer paso en la mayoría de los análisis estadísticos es la organización y descripción efectiva de los datos [pág 3]. Una forma común y conveniente de organizar los datos es usando una matriz de datos, especialmente si se recolectan datos en una hoja de cálculo [pág 4] o una base de datos (Oracle, Posgres, entre otras). En una matriz de datos, cada fila representa un solo caso o unidad observacional, y cada columna representa una variable [pág 4, pág 5]. Por ejemplo, en un conjunto de datos sobre préstamos cada fila podría ser un solo préstamo, y las columnas serían características como el monto del préstamo o la tasa de interés\n\n\n\nLas variables pueden clasificarse en diferentes tipos [pág 7]:\n\nVariables Numéricas: Pueden tomar un amplio rango de valores numéricos, y tiene sentido realizar operaciones matemáticas como la suma o el promedio con ellas [pág 7].\n\nVariables Numéricas (ordinal) Discretas: Solo pueden tomar números enteros no negativos, típicamente representando conteos [pág 8]. Por ejemplo, la variable número de migrañas es una variable numérica discreta [pág pág 8].\nVariables Numéricas Continuas: Pueden tomar cualquier valor numérico dentro de un rango dado [pág i]. Variables como la tasa de desempleo son numéricas [pág 7]. Los niveles de contaminación del aire, como monóxido de carbono o material particulado (PM10), son variables numéricas continuas [pág 9, 10].\n\nVariables Categóricas: Tienen respuestas que caen en categorías [pág 8]. Los posibles valores se llaman niveles de la variable [pág i]. Por ejemplo, una variable que indica el grupo de un experimento (tratamiento o control) es categórica [pág 8]. La variable propiedad de la vivienda es categórica. Las variables categóricas pueden dividirse además en:\n\nNominales (categóricas no ordenadas): Las categorías no tienen un orden natural [pág i]. La variable estado de EE.UU. es un ejemplo de variable categórica nominal [pág i]. El grupo de tratamiento o control en un experimento es categórica sin un orden inherente [pág 8].\nOrdinales (categóricas ordenadas): Las categorías tienen un orden significativo [pág i]. La variable nivel educativo mediano con niveles como por debajo de la escuela secundaria, diploma de escuela secundaria, alguna universidad y licenciatura, es categórica ordinal [pág 32, 33, i].\n\n\n\n\n\nMuchos análisis están motivados por la búsqueda de relaciones entre variables [pág i]. Cuando dos variables están relacionadas, se dice que están asociadas [pág 11]. Si una variable tiende a aumentar a medida que la otra aumenta, muestran una asociación positiva [pág 11]. Si una aumenta a medida que la otra disminuye, muestran una asociación negativa [pág 11]. Cuando se intenta comprender si un cambio en una variable podría causar un cambio en otra, podríamos identificar una variable explicativa (la causa potencial) y una variable de respuesta (el efecto potencial) [pág 12]. Las variables explicativas a veces se denominan variables independientes y las variables de respuesta variables dependientes, aunque el texto prefiere no usar esta terminología para evitar confusiones [pág 9]. Diagramas de dispersión (Scatterplots) son una herramienta gráfica utilizada para explorar visualmente la relación entre dos variables numéricas, donde cada punto representa un solo caso [pág 13, 14].\n\n\n\nLa forma en que se recolectan los datos impacta significativamente las conclusiones que pueden extraerse [pág 15]. Hay dos tipos principales de métodos de recolección de datos [pág 16]:\n\nEstudios Observacionales: Implican la recolección de datos sin interferir directamente en cómo surgen los datos [pág 16]. Los investigadores simplemente observan los datos [pág 16]. Esto puede incluir encuestas, revisión de registros o seguimiento de cohortes [pág 16, 17]. Los estudios observacionales pueden ser prospectivos, recolectando información a medida que los eventos se desarrollan (como el Nurses’ Health Study), o retrospectivos, recolectando datos sobre eventos pasados (como la revisión de registros médicos) [pág 17]. Si bien los estudios observacionales pueden proporcionar evidencia de una asociación natural entre variables, no pueden por sí solos mostrar una conexión causal debido a la posibilidad de variables ocultas o de confusión (confounding variables) [pág 16, 18]. Una variable de confusión es una variable que está asociada tanto con la variable explicativa como con la variable de respuesta, creando una asociación aparente entre ellas [pág 18].\nExperimentos: Implican que los investigadores intervienen activamente asignando casos aleatoriamente a diferentes grupos [pág 12]. Generalmente, hay un grupo de tratamiento y un grupo de control [pág 12, 19, 20]. Los principios clave del diseño experimental incluyen control, aleatorización y replicación [pág 21, 22]. El control implica que los investigadores hacen todo lo posible para controlar cualquier otra diferencia entre los grupos asignados [pág 21]. La aleatorización es crucial para asignar pacientes a grupos de tratamiento para tener en cuenta variables que no pueden controlarse y evitar sesgos accidentales [pág 22]. La replicación se refiere a observar una muestra suficientemente grande en un solo estudio o que un grupo de científicos replique un estudio completo [pág 22]. Un cuarto principio es el bloqueo, donde los individuos se agrupan primero según una variable conocida o sospechada que influye en la respuesta, y luego se asignan aleatoriamente casos dentro de cada bloque a los grupos de tratamiento [pág 23]. Esto asegura una representación igual de esta variable en cada grupo de tratamiento [pág 23]. Un experimento aleatorizado puede incluir un placebo (un tratamiento simulado) en el grupo de control para ayudar a medir el impacto médico real del tratamiento [pág 12, 24, 25]. Los experimentos, a diferencia de los estudios observacionales, pueden proporcionar evidencia de una conexión causal [pág 9, 12].\n\nLa asociación no implica causalidad; la causalidad solo puede inferirse de un experimento aleatorizado [pág 9].\n\n\n\nCuando se estudia un grupo grande (población), a menudo es poco práctico recolectar datos de cada caso [pág 26]. En su lugar, se toma una muestra, que es un subconjunto de la población [pág 26]. Las conclusiones sobre la población se extraen luego basándose en los datos de la muestra [pág 26]. Un sesgo se introduce en una muestra si el método de recolección tiende a producir resultados que sistemáticamente difieren del valor poblacional real [pág 27]. Los datos recolectados al azar se llaman evidencia anecdótica y deben tratarse con precaución, ya que pueden representar casos extraordinarios en lugar de ser representativos de la población [pág 28].\nPara asegurar que una muestra sea representativa de la población y reducir el sesgo [pág 27], las técnicas de muestreo aleatorio son cruciales [pág 27]. Existen diferentes técnicas de muestreo aleatorio [pág 29]:\n\nMuestreo Aleatorio Simple: Es el tipo más básico, donde cada caso en la población tiene la misma probabilidad de ser seleccionado, similar a una rifa [pág 27]. No hay conexión implícita entre los casos seleccionados [pág 27].\nMuestreo Estratificado: Implica dividir la población en grupos llamados estratos (donde los casos dentro de cada estrato son similares con respecto a una característica importante) y luego muestrear aleatoriamente dentro de cada estrato [pág 29]. Esto asegura una representación igual de estos grupos en la muestra [pág i].\nMuestreo por Conglomerados (Cluster sampling): Implica dividir la población en muchos grupos llamados conglomerados (clusters), muestrear un número fijo de conglomerados seleccionados al azar, e incluir todas las observaciones de los conglomerados seleccionados [pág 29].\nMuestreo Multietápico (Multistage sampling): Es similar al muestreo por conglomerados, pero implica tomar una muestra aleatoria dentro de los conglomerados seleccionados en lugar de incluir todas las observaciones [pág 30]. El muestreo por conglomerados y multietápico pueden ayudar a reducir los costos de recolección de datos [pág 30].\n\n\n\n\nEl alcance de la inferencia se refiere a la medida en que los resultados de un estudio pueden generalizarse a la población y si se pueden establecer conclusiones causales [pág 31-34]. El muestreo aleatorio permite generalizaciones a la población de la que se extrajo la muestra [pág 32, 34], mientras que la asignación aleatoria en un experimento permite conclusiones causales [pág 33, 34].\n\n\n\nFinalmente, las muestras nos permiten calcular estadísticas de resumen, que son números únicos que resumen una gran cantidad de datos [pág i]. Estas estadísticas muestrales, como la media muestral (\\(\\bar{x}\\)) [pág 35] o la proporción muestral (\\(\\hat{p}\\)) [pág 36], se utilizan para estimar parámetros poblacionales desconocidos que describen toda la población [pág 37]. El parámetro poblacional para la media se denota con la letra griega mu (\\(\\mu\\)) [pág 38].\nEn general, comprender e interpretar datos usando estadísticas implica una recolección de datos cuidadosa, la organización y descripción de los datos a través de variables y visualizaciones, la síntesis de las características clave con estadísticas y el uso de métodos de inferencia apropiados (introducidos en capítulos posteriores, como el Capítulo 5) para extraer conclusiones fiables sobre las poblaciones basándose en la evidencia de la muestra [i, 4]. ### 1. Frecuencia Absoluta (\\(n_i\\))\nLa frecuencia absoluta de una categoría o clase \\(x_i\\) es el número de veces que dicha categoría o clase aparece en el conjunto de datos.\n\n\\(n_i\\): Frecuencia absoluta de la categoría/clase \\(x_i\\).\n\nLa suma de todas las frecuencias absolutas debe ser igual al número total de observaciones \\(N\\): \\[\n\\sum_{i=1}^{k} n_i = N\n\\]\n\n\n\nLa frecuencia relativa de una categoría o clase \\(x_i\\) es la proporción de veces que dicha categoría o clase aparece en el conjunto de datos. Se calcula dividiendo la frecuencia absoluta \\(n_i\\) por el número total de observaciones \\(N\\).\n\n\\(f_i\\): Frecuencia relativa de la categoría/clase \\(x_i\\).\n\n\\[\nf_i = \\frac{n_i}{N}\n\\] La suma de todas las frecuencias relativas es igual a 1: \\[\n\\sum_{i=1}^{k} f_i = \\sum_{i=1}^{k} \\frac{n_i}{N} = \\frac{1}{N} \\sum_{i=1}^{k} n_i = \\frac{N}{N} = 1\n\\] Para expresar la frecuencia relativa como un porcentaje, se multiplica por 100: \\[\nf_i (\\%) = \\frac{n_i}{N} \\times 100\\%\n\\]\n\n\n\nLa frecuencia acumulada hasta una categoría o clase \\(x_i\\) es la suma de las frecuencias absolutas de todas las categorías o clases anteriores o iguales a \\(x_i\\). Esto implica que las categorías/clases deben tener un orden natural (datos ordinales o cuantitativos agrupados).\n\n\\(N_i\\): Frecuencia acumulada hasta la categoría/clase \\(x_i\\).\n\n\\[\nN_i = \\sum_{j=1}^{i} n_j = n_1 + n_2 + \\dots + n_i\n\\] También se puede definir recursivamente: \\(N_1 = n_1\\) \\(N_i = N_{i-1} + n_i\\) para \\(i &gt; 1\\).\nLa frecuencia acumulada de la última categoría/clase (\\(x_k\\)) es igual al número total de observaciones \\(N\\): \\[\nN_k = N\n\\]\n\n\n\nLa frecuencia relativa acumulada hasta una categoría o clase \\(x_i\\) es la suma de las frecuencias relativas de todas las categorías o clases anteriores o iguales a \\(x_i\\). También se puede calcular dividiendo la frecuencia acumulada \\(N_i\\) por el número total de observaciones \\(N\\). Nuevamente, esto requiere un orden en las categorías/clases.\n\n\\(F_i\\): Frecuencia relativa acumulada hasta la categoría/clase \\(x_i\\).\n\n\\[\nF_i = \\sum_{j=1}^{i} f_j = f_1 + f_2 + \\dots + f_i\n\\] Alternativamente: \\[\nF_i = \\frac{N_i}{N}\n\\] También se puede definir recursivamente: \\(F_1 = f_1\\) \\(F_i = F_{i-1} + f_i\\) para \\(i &gt; 1\\).\nLa frecuencia relativa acumulada de la última categoría/clase (\\(x_k\\)) es igual a 1 (o 100%): \\[\nF_k = 1\n\\] Para expresarla como porcentaje: \\[\nF_i (\\%) = \\left( \\sum_{j=1}^{i} f_j \\right) \\times 100\\% = \\frac{N_i}{N} \\times 100\\%\n\\]\n\n\n\nUna tabla de frecuencias típica se vería así:\n\\[\n\\begin{array}{c|c|c|c|c}\n\\text{Categoría/Clase} & \\text{Frec. Absoluta} & \\text{Frec. Relativa} & \\text{Frec. Acumulada} & \\text{Frec. Rel. Acumulada} \\\\\n(x_i) & (n_i) & (f_i) & (N_i) & (F_i) \\\\\n\\hline\nx_1 & n_1 & f_1 = n_1/N & N_1 = n_1 & F_1 = f_1 \\\\\nx_2 & n_2 & f_2 = n_2/N & N_2 = n_1+n_2 & F_2 = f_1+f_2 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\nx_i & n_i & f_i = n_i/N & N_i = \\sum_{j=1}^{i} n_j & F_i = \\sum_{j=1}^{i} f_j \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\nx_k & n_k & f_k = n_k/N & N_k = N & F_k = 1 \\\\\n\\hline\n\\text{Total} & N & 1 (\\text{o } 100\\%) & - & - \\\\\n\\end{array}\n\\]\nNota: Para datos puramente nominales (sin orden inherente), las frecuencias acumuladas (absoluta y relativa) no suelen tener una interpretación útil y a menudo se omiten."
  },
  {
    "objectID": "clase1_diplomado.html#organización-y-descripción-de-datos",
    "href": "clase1_diplomado.html#organización-y-descripción-de-datos",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "El primer paso en la mayoría de los análisis estadísticos es la organización y descripción efectiva de los datos [pág 3]. Una forma común y conveniente de organizar los datos es usando una matriz de datos, especialmente si se recolectan datos en una hoja de cálculo [pág 4] o una base de datos (Oracle, Posgres, entre otras). En una matriz de datos, cada fila representa un solo caso o unidad observacional, y cada columna representa una variable [pág 4, pág 5]. Por ejemplo, en un conjunto de datos sobre préstamos cada fila podría ser un solo préstamo, y las columnas serían características como el monto del préstamo o la tasa de interés"
  },
  {
    "objectID": "clase1_diplomado.html#tipos-de-variables",
    "href": "clase1_diplomado.html#tipos-de-variables",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "Las variables pueden clasificarse en diferentes tipos [pág 7]:\n\nVariables Numéricas: Pueden tomar un amplio rango de valores numéricos, y tiene sentido realizar operaciones matemáticas como la suma o el promedio con ellas [pág 7].\n\nVariables Numéricas (ordinal) Discretas: Solo pueden tomar números enteros no negativos, típicamente representando conteos [pág 8]. Por ejemplo, la variable número de migrañas es una variable numérica discreta [pág pág 8].\nVariables Numéricas Continuas: Pueden tomar cualquier valor numérico dentro de un rango dado [pág i]. Variables como la tasa de desempleo son numéricas [pág 7]. Los niveles de contaminación del aire, como monóxido de carbono o material particulado (PM10), son variables numéricas continuas [pág 9, 10].\n\nVariables Categóricas: Tienen respuestas que caen en categorías [pág 8]. Los posibles valores se llaman niveles de la variable [pág i]. Por ejemplo, una variable que indica el grupo de un experimento (tratamiento o control) es categórica [pág 8]. La variable propiedad de la vivienda es categórica. Las variables categóricas pueden dividirse además en:\n\nNominales (categóricas no ordenadas): Las categorías no tienen un orden natural [pág i]. La variable estado de EE.UU. es un ejemplo de variable categórica nominal [pág i]. El grupo de tratamiento o control en un experimento es categórica sin un orden inherente [pág 8].\nOrdinales (categóricas ordenadas): Las categorías tienen un orden significativo [pág i]. La variable nivel educativo mediano con niveles como por debajo de la escuela secundaria, diploma de escuela secundaria, alguna universidad y licenciatura, es categórica ordinal [pág 32, 33, i]."
  },
  {
    "objectID": "clase1_diplomado.html#relaciones-entre-variables",
    "href": "clase1_diplomado.html#relaciones-entre-variables",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "Muchos análisis están motivados por la búsqueda de relaciones entre variables [pág i]. Cuando dos variables están relacionadas, se dice que están asociadas [pág 11]. Si una variable tiende a aumentar a medida que la otra aumenta, muestran una asociación positiva [pág 11]. Si una aumenta a medida que la otra disminuye, muestran una asociación negativa [pág 11]. Cuando se intenta comprender si un cambio en una variable podría causar un cambio en otra, podríamos identificar una variable explicativa (la causa potencial) y una variable de respuesta (el efecto potencial) [pág 12]. Las variables explicativas a veces se denominan variables independientes y las variables de respuesta variables dependientes, aunque el texto prefiere no usar esta terminología para evitar confusiones [pág 9]. Diagramas de dispersión (Scatterplots) son una herramienta gráfica utilizada para explorar visualmente la relación entre dos variables numéricas, donde cada punto representa un solo caso [pág 13, 14]."
  },
  {
    "objectID": "clase1_diplomado.html#recolección-de-datos-estudios-observacionales-y-experimentos",
    "href": "clase1_diplomado.html#recolección-de-datos-estudios-observacionales-y-experimentos",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "La forma en que se recolectan los datos impacta significativamente las conclusiones que pueden extraerse [pág 15]. Hay dos tipos principales de métodos de recolección de datos [pág 16]:\n\nEstudios Observacionales: Implican la recolección de datos sin interferir directamente en cómo surgen los datos [pág 16]. Los investigadores simplemente observan los datos [pág 16]. Esto puede incluir encuestas, revisión de registros o seguimiento de cohortes [pág 16, 17]. Los estudios observacionales pueden ser prospectivos, recolectando información a medida que los eventos se desarrollan (como el Nurses’ Health Study), o retrospectivos, recolectando datos sobre eventos pasados (como la revisión de registros médicos) [pág 17]. Si bien los estudios observacionales pueden proporcionar evidencia de una asociación natural entre variables, no pueden por sí solos mostrar una conexión causal debido a la posibilidad de variables ocultas o de confusión (confounding variables) [pág 16, 18]. Una variable de confusión es una variable que está asociada tanto con la variable explicativa como con la variable de respuesta, creando una asociación aparente entre ellas [pág 18].\nExperimentos: Implican que los investigadores intervienen activamente asignando casos aleatoriamente a diferentes grupos [pág 12]. Generalmente, hay un grupo de tratamiento y un grupo de control [pág 12, 19, 20]. Los principios clave del diseño experimental incluyen control, aleatorización y replicación [pág 21, 22]. El control implica que los investigadores hacen todo lo posible para controlar cualquier otra diferencia entre los grupos asignados [pág 21]. La aleatorización es crucial para asignar pacientes a grupos de tratamiento para tener en cuenta variables que no pueden controlarse y evitar sesgos accidentales [pág 22]. La replicación se refiere a observar una muestra suficientemente grande en un solo estudio o que un grupo de científicos replique un estudio completo [pág 22]. Un cuarto principio es el bloqueo, donde los individuos se agrupan primero según una variable conocida o sospechada que influye en la respuesta, y luego se asignan aleatoriamente casos dentro de cada bloque a los grupos de tratamiento [pág 23]. Esto asegura una representación igual de esta variable en cada grupo de tratamiento [pág 23]. Un experimento aleatorizado puede incluir un placebo (un tratamiento simulado) en el grupo de control para ayudar a medir el impacto médico real del tratamiento [pág 12, 24, 25]. Los experimentos, a diferencia de los estudios observacionales, pueden proporcionar evidencia de una conexión causal [pág 9, 12].\n\nLa asociación no implica causalidad; la causalidad solo puede inferirse de un experimento aleatorizado [pág 9]."
  },
  {
    "objectID": "clase1_diplomado.html#principios-de-muestreo",
    "href": "clase1_diplomado.html#principios-de-muestreo",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "Cuando se estudia un grupo grande (población), a menudo es poco práctico recolectar datos de cada caso [pág 26]. En su lugar, se toma una muestra, que es un subconjunto de la población [pág 26]. Las conclusiones sobre la población se extraen luego basándose en los datos de la muestra [pág 26]. Un sesgo se introduce en una muestra si el método de recolección tiende a producir resultados que sistemáticamente difieren del valor poblacional real [pág 27]. Los datos recolectados al azar se llaman evidencia anecdótica y deben tratarse con precaución, ya que pueden representar casos extraordinarios en lugar de ser representativos de la población [pág 28].\nPara asegurar que una muestra sea representativa de la población y reducir el sesgo [pág 27], las técnicas de muestreo aleatorio son cruciales [pág 27]. Existen diferentes técnicas de muestreo aleatorio [pág 29]:\n\nMuestreo Aleatorio Simple: Es el tipo más básico, donde cada caso en la población tiene la misma probabilidad de ser seleccionado, similar a una rifa [pág 27]. No hay conexión implícita entre los casos seleccionados [pág 27].\nMuestreo Estratificado: Implica dividir la población en grupos llamados estratos (donde los casos dentro de cada estrato son similares con respecto a una característica importante) y luego muestrear aleatoriamente dentro de cada estrato [pág 29]. Esto asegura una representación igual de estos grupos en la muestra [pág i].\nMuestreo por Conglomerados (Cluster sampling): Implica dividir la población en muchos grupos llamados conglomerados (clusters), muestrear un número fijo de conglomerados seleccionados al azar, e incluir todas las observaciones de los conglomerados seleccionados [pág 29].\nMuestreo Multietápico (Multistage sampling): Es similar al muestreo por conglomerados, pero implica tomar una muestra aleatoria dentro de los conglomerados seleccionados en lugar de incluir todas las observaciones [pág 30]. El muestreo por conglomerados y multietápico pueden ayudar a reducir los costos de recolección de datos [pág 30]."
  },
  {
    "objectID": "clase1_diplomado.html#alcance-de-la-inferencia",
    "href": "clase1_diplomado.html#alcance-de-la-inferencia",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "El alcance de la inferencia se refiere a la medida en que los resultados de un estudio pueden generalizarse a la población y si se pueden establecer conclusiones causales [pág 31-34]. El muestreo aleatorio permite generalizaciones a la población de la que se extrajo la muestra [pág 32, 34], mientras que la asignación aleatoria en un experimento permite conclusiones causales [pág 33, 34]."
  },
  {
    "objectID": "clase1_diplomado.html#estadísticas-de-resumen-y-parámetros-poblacionales",
    "href": "clase1_diplomado.html#estadísticas-de-resumen-y-parámetros-poblacionales",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "Finalmente, las muestras nos permiten calcular estadísticas de resumen, que son números únicos que resumen una gran cantidad de datos [pág i]. Estas estadísticas muestrales, como la media muestral (\\(\\bar{x}\\)) [pág 35] o la proporción muestral (\\(\\hat{p}\\)) [pág 36], se utilizan para estimar parámetros poblacionales desconocidos que describen toda la población [pág 37]. El parámetro poblacional para la media se denota con la letra griega mu (\\(\\mu\\)) [pág 38].\nEn general, comprender e interpretar datos usando estadísticas implica una recolección de datos cuidadosa, la organización y descripción de los datos a través de variables y visualizaciones, la síntesis de las características clave con estadísticas y el uso de métodos de inferencia apropiados (introducidos en capítulos posteriores, como el Capítulo 5) para extraer conclusiones fiables sobre las poblaciones basándose en la evidencia de la muestra [i, 4]. ### 1. Frecuencia Absoluta (\\(n_i\\))\nLa frecuencia absoluta de una categoría o clase \\(x_i\\) es el número de veces que dicha categoría o clase aparece en el conjunto de datos.\n\n\\(n_i\\): Frecuencia absoluta de la categoría/clase \\(x_i\\).\n\nLa suma de todas las frecuencias absolutas debe ser igual al número total de observaciones \\(N\\): \\[\n\\sum_{i=1}^{k} n_i = N\n\\]"
  },
  {
    "objectID": "clase1_diplomado.html#frecuencia-relativa-f_i",
    "href": "clase1_diplomado.html#frecuencia-relativa-f_i",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "La frecuencia relativa de una categoría o clase \\(x_i\\) es la proporción de veces que dicha categoría o clase aparece en el conjunto de datos. Se calcula dividiendo la frecuencia absoluta \\(n_i\\) por el número total de observaciones \\(N\\).\n\n\\(f_i\\): Frecuencia relativa de la categoría/clase \\(x_i\\).\n\n\\[\nf_i = \\frac{n_i}{N}\n\\] La suma de todas las frecuencias relativas es igual a 1: \\[\n\\sum_{i=1}^{k} f_i = \\sum_{i=1}^{k} \\frac{n_i}{N} = \\frac{1}{N} \\sum_{i=1}^{k} n_i = \\frac{N}{N} = 1\n\\] Para expresar la frecuencia relativa como un porcentaje, se multiplica por 100: \\[\nf_i (\\%) = \\frac{n_i}{N} \\times 100\\%\n\\]"
  },
  {
    "objectID": "clase1_diplomado.html#frecuencia-acumulada-n_i",
    "href": "clase1_diplomado.html#frecuencia-acumulada-n_i",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "La frecuencia acumulada hasta una categoría o clase \\(x_i\\) es la suma de las frecuencias absolutas de todas las categorías o clases anteriores o iguales a \\(x_i\\). Esto implica que las categorías/clases deben tener un orden natural (datos ordinales o cuantitativos agrupados).\n\n\\(N_i\\): Frecuencia acumulada hasta la categoría/clase \\(x_i\\).\n\n\\[\nN_i = \\sum_{j=1}^{i} n_j = n_1 + n_2 + \\dots + n_i\n\\] También se puede definir recursivamente: \\(N_1 = n_1\\) \\(N_i = N_{i-1} + n_i\\) para \\(i &gt; 1\\).\nLa frecuencia acumulada de la última categoría/clase (\\(x_k\\)) es igual al número total de observaciones \\(N\\): \\[\nN_k = N\n\\]"
  },
  {
    "objectID": "clase1_diplomado.html#frecuencia-relativa-acumulada-f_i",
    "href": "clase1_diplomado.html#frecuencia-relativa-acumulada-f_i",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "La frecuencia relativa acumulada hasta una categoría o clase \\(x_i\\) es la suma de las frecuencias relativas de todas las categorías o clases anteriores o iguales a \\(x_i\\). También se puede calcular dividiendo la frecuencia acumulada \\(N_i\\) por el número total de observaciones \\(N\\). Nuevamente, esto requiere un orden en las categorías/clases.\n\n\\(F_i\\): Frecuencia relativa acumulada hasta la categoría/clase \\(x_i\\).\n\n\\[\nF_i = \\sum_{j=1}^{i} f_j = f_1 + f_2 + \\dots + f_i\n\\] Alternativamente: \\[\nF_i = \\frac{N_i}{N}\n\\] También se puede definir recursivamente: \\(F_1 = f_1\\) \\(F_i = F_{i-1} + f_i\\) para \\(i &gt; 1\\).\nLa frecuencia relativa acumulada de la última categoría/clase (\\(x_k\\)) es igual a 1 (o 100%): \\[\nF_k = 1\n\\] Para expresarla como porcentaje: \\[\nF_i (\\%) = \\left( \\sum_{j=1}^{i} f_j \\right) \\times 100\\% = \\frac{N_i}{N} \\times 100\\%\n\\]"
  },
  {
    "objectID": "clase1_diplomado.html#tabla-resumen-de-frecuencias",
    "href": "clase1_diplomado.html#tabla-resumen-de-frecuencias",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "",
    "text": "Una tabla de frecuencias típica se vería así:\n\\[\n\\begin{array}{c|c|c|c|c}\n\\text{Categoría/Clase} & \\text{Frec. Absoluta} & \\text{Frec. Relativa} & \\text{Frec. Acumulada} & \\text{Frec. Rel. Acumulada} \\\\\n(x_i) & (n_i) & (f_i) & (N_i) & (F_i) \\\\\n\\hline\nx_1 & n_1 & f_1 = n_1/N & N_1 = n_1 & F_1 = f_1 \\\\\nx_2 & n_2 & f_2 = n_2/N & N_2 = n_1+n_2 & F_2 = f_1+f_2 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\nx_i & n_i & f_i = n_i/N & N_i = \\sum_{j=1}^{i} n_j & F_i = \\sum_{j=1}^{i} f_j \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\nx_k & n_k & f_k = n_k/N & N_k = N & F_k = 1 \\\\\n\\hline\n\\text{Total} & N & 1 (\\text{o } 100\\%) & - & - \\\\\n\\end{array}\n\\]\nNota: Para datos puramente nominales (sin orden inherente), las frecuencias acumuladas (absoluta y relativa) no suelen tener una interpretación útil y a menudo se omiten."
  },
  {
    "objectID": "clase1_diplomado.html#por-qué-anaconda",
    "href": "clase1_diplomado.html#por-qué-anaconda",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "¿Por qué Anaconda?",
    "text": "¿Por qué Anaconda?\n\nGestor de Paquetes (Conda): Facilita la instalación, actualización y gestión de librerías (paquetes) y sus dependencias.\nEntornos Virtuales: Permite crear entornos aislados para diferentes proyectos, evitando conflictos entre versiones de paquetes.\nPreinstalación de Librerías Científicas: Viene con muchas librerías populares para ciencia de datos preinstaladas (NumPy, Pandas, Matplotlib, Scikit-learn, Jupyter Notebook, etc.)."
  },
  {
    "objectID": "clase1_diplomado.html#pasos-para-la-instalación-de-anaconda",
    "href": "clase1_diplomado.html#pasos-para-la-instalación-de-anaconda",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Pasos para la Instalación de Anaconda",
    "text": "Pasos para la Instalación de Anaconda\n\nDescargar el Instalador:\n\nVe al sitio web oficial de Anaconda: https://www.anaconda.com/products/distribution.\nDescarga el instalador gráfico correspondiente a tu sistema operativo (Windows, macOS o Linux). Se recomienda descargar la versión más reciente de Python 3.x.\n\nEjecutar el Instalador:\n\nWindows: Haz doble clic en el archivo .exe descargado. Sigue las instrucciones del asistente.\n\nSe recomienda instalar para “Just Me” (Solo yo) a menos que necesites una instalación para todos los usuarios.\nImportante: Durante la instalación, es posible que se te pregunte si deseas “Add Anaconda to my PATH environment variable” (Añadir Anaconda a mi variable de entorno PATH). Generalmente NO se recomienda marcar esta opción si eres un usuario nuevo, ya que puede interferir con otras instalaciones de Python. Anaconda Prompt (o Anaconda Navigator) te dará acceso a los entornos de conda sin necesidad de esto. Si eres un usuario avanzado y sabes lo que haces, puedes considerarlo.\nMarca la opción “Register Anaconda as my default Python” (Registrar Anaconda como mi Python por defecto) si no tienes otra instalación de Python que quieras priorizar.\n\nmacOS: Haz doble clic en el archivo .pkg descargado. Sigue las instrucciones del asistente. Acepta los acuerdos de licencia y selecciona el destino de la instalación.\nLinux: Abre una terminal, navega al directorio donde descargaste el archivo .sh y ejecútalo con el comando: bash     bash Anaconda3-&lt;version&gt;-Linux-x86_64.sh (Reemplaza &lt;version&gt; con la versión específica que descargaste). Sigue las instrucciones en la terminal. Acepta el acuerdo de licencia. Cuando te pregunte si deseas inicializar Anaconda3 ejecutando conda init, se recomienda responder yes.\n\nVerificar la Instalación:\n\nDespués de la instalación, cierra y vuelve a abrir tu terminal (o Anaconda Prompt en Windows).\nEscribe el comando: bash     conda --version Deberías ver la versión de conda instalada.\nTambién puedes verificar la versión de Python: bash     python --version"
  },
  {
    "objectID": "clase1_diplomado.html#uso-básico-de-conda-opcional-para-empezar",
    "href": "clase1_diplomado.html#uso-básico-de-conda-opcional-para-empezar",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Uso Básico de Conda (Opcional para Empezar)",
    "text": "Uso Básico de Conda (Opcional para Empezar)\n\nPara crear un nuevo entorno llamado mi_entorno con Python 3.9 (o la versión que prefieras): bash     conda create --name mi_entorno python=3.9\nPara activar el entorno: bash     conda activate mi_entorno\nPara instalar un paquete (por ejemplo, seaborn) en el entorno activo: bash     conda install seaborn\nPara desactivar el entorno: bash     conda deactivate Para este curso, trabajar en el entorno base de Anaconda será suficiente inicialmente, pero aprender a usar entornos es una buena práctica para proyectos más complejos."
  },
  {
    "objectID": "clase1_diplomado.html#pasos-para-la-instalación-de-r",
    "href": "clase1_diplomado.html#pasos-para-la-instalación-de-r",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Pasos para la Instalación de R",
    "text": "Pasos para la Instalación de R\n\nDescargar R:\n\nVe al sitio web oficial de CRAN (Comprehensive R Archive Network): https://cran.r-project.org/.\nEn la sección “Download and Install R”, haz clic en el enlace correspondiente a tu sistema operativo:\n\nDownload R for Linux\nDownload R for macOS\nDownload R for Windows\n\nSigue las instrucciones específicas de tu SO:\n\nWindows: Haz clic en “base”, luego en “Download R-X.Y.Z for Windows” (donde X.Y.Z es la última versión).\nmacOS: Descarga el archivo .pkg más reciente para tu versión de macOS (asegúrate de elegir la correcta para tu arquitectura de procesador, Intel o Apple Silicon/ARM).\nLinux: Sigue las instrucciones para tu distribución específica (Debian, Ubuntu, Fedora, etc.). Generalmente implica añadir un repositorio de CRAN y usar el gestor de paquetes de tu sistema (ej. sudo apt-get install r-base).\n\n\nEjecutar el Instalador:\n\nWindows: Haz doble clic en el archivo .exe descargado y sigue las instrucciones del asistente. Acepta la configuración por defecto a menos que tengas una razón específica para cambiarla.\nmacOS: Haz doble clic en el archivo .pkg y sigue las instrucciones.\n\nVerificar la Instalación (Opcional):\n\nPuedes abrir la consola de R que se instala (RGui en Windows, o simplemente escribir R en la terminal en macOS/Linux) y verás el mensaje de bienvenida con la versión.\n\n\nNota: La instalación de R solo proporciona el motor del lenguaje y una interfaz de consola básica. Para una experiencia de desarrollo mucho más amigable y productiva, instalaremos RStudio."
  },
  {
    "objectID": "clase1_diplomado.html#pasos-para-la-instalación-de-rstudio-desktop",
    "href": "clase1_diplomado.html#pasos-para-la-instalación-de-rstudio-desktop",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Pasos para la Instalación de RStudio Desktop",
    "text": "Pasos para la Instalación de RStudio Desktop\n\nDescargar RStudio Desktop:\n\nVe al sitio web oficial de Posit: https://posit.co/download/rstudio-desktop/.\nEl sitio web debería detectar tu sistema operativo y sugerir la versión adecuada. Descarga el instalador gratuito “RStudio Desktop”.\n\nEjecutar el Instalador:\n\nWindows: Haz doble clic en el archivo .exe descargado y sigue las instrucciones del asistente.\nmacOS: Haz doble clic en el archivo .dmg descargado, y luego arrastra el icono de RStudio a tu carpeta de Aplicaciones.\nLinux: Descarga el archivo .deb (para Debian/Ubuntu) o .rpm (para Fedora/RHEL/openSUSE) e instálalo usando el gestor de paquetes de tu sistema. Por ejemplo, para un archivo .deb: bash     sudo dpkg -i rstudio-&lt;version&gt;-amd64.deb     # Si hay problemas de dependencias, ejecuta:     sudo apt-get install -f (Reemplaza &lt;version&gt; con la versión específica que descargaste).\n\nAbrir RStudio:\n\nUna vez instalado, busca RStudio en tus aplicaciones y ábrelo.\nRStudio debería detectar automáticamente tu instalación de R. Si por alguna razón no lo hace, puedes configurarlo manualmente en las opciones globales de RStudio (Tools &gt; Global Options &gt; General &gt; R version)."
  },
  {
    "objectID": "clase1_diplomado.html#pasos-para-configurar-vs-code-para-r-positron",
    "href": "clase1_diplomado.html#pasos-para-configurar-vs-code-para-r-positron",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Pasos para Configurar VS Code para R (Positron)",
    "text": "Pasos para Configurar VS Code para R (Positron)\n\nInstalar Visual Studio Code:\n\nSi aún no lo tienes, descarga VS Code desde https://code.visualstudio.com/ e instálalo.\n\nInstalar Extensiones Clave:\n\nAbre VS Code.\nVe a la vista de Extensiones (el icono de cuadrados en la barra lateral izquierda, o presiona Ctrl+Shift+X).\nBusca e instala las siguientes extensiones:\n\nR (de REditorSupport o la extensión oficial “R” de Posit). Esta extensión proporciona resaltado de sintaxis, completado de código, integración con la terminal de R, un visor de datos y gráficos, etc.\nPython (de Microsoft): Para soporte completo de Python si también lo usarás en VS Code.\nQuarto (de Posit): Para trabajar con documentos Quarto, que permiten combinar R, Python, Markdown, LaTeX, y más, para crear documentos dinámicos y reproducibles.\n\n\nConfigurar la Extensión de R (si es necesario):\n\nNormalmente, la extensión de R detecta tu instalación de R automáticamente. Si no, puede que necesites especificar la ruta a tu ejecutable de R en los ajustes de la extensión (Archivo &gt; Preferencias &gt; Configuración, luego busca “R path” o ajustes relacionados con R).\n\n\nVS Code con estas extensiones ofrece un entorno muy flexible y potente, especialmente si trabajas con múltiples lenguajes o prefieres un editor altamente personalizable."
  },
  {
    "objectID": "clase1_diplomado.html#lectura-de-datos",
    "href": "clase1_diplomado.html#lectura-de-datos",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Lectura de datos",
    "text": "Lectura de datos\nVamos a leer masivamente la encuesta de hogares, filtrar Bogotá y seleccioanr variables relevantes\n\nRPython\n\n\n\n# Definir los nombres de los meses para construir los nombres de archivo\nmeses_abreviados &lt;- c(\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \n                      \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\")\n\n# Crear una lista para almacenar los dataframes de cada mes\nlista_dataframes_mes &lt;- list()\n\n# Bucle para leer cada archivo\nfor (mes_actual in meses_abreviados) {\n  nombre_archivo &lt;- paste0(\"Datos del hogar y la vivienda_\", mes_actual, \".CSV\")\n  cat(\"Leyendo archivo:\", nombre_archivo, \"\\n\") # Para ver el progreso\n  \n  # Intentar leer el archivo. `tryCatch` es para manejar si algún archivo falta.\n  datos_mes &lt;- tryCatch({\n    read_delim(nombre_archivo, delim = \";\") # Usar read_csv2 si el separador es ; y decimal es ,\n  }, error = function(e) {\n    warning(paste(\"No se pudo leer el archivo:\", nombre_archivo, \"-\", e$message))\n    return(NULL) # Retorna NULL si hay un error\n  })\n  \n  # Si el dataframe se leyó correctamente, añadirlo a la lista\n  if (!is.null(datos_mes)) {\n    lista_dataframes_mes[[mes_actual]] &lt;- datos_mes\n  }\n}\n\nLeyendo archivo: Datos del hogar y la vivienda_ene.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_feb.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_mar.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_abr.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_may.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_jun.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_jul.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_ago.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_sep.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_oct.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_nov.CSV \n\n\nLeyendo archivo: Datos del hogar y la vivienda_dic.CSV \n\nlista_dataframes_mes$oct$MES &lt;- as.character(lista_dataframes_mes$oct$MES)\nlista_dataframes_mes$nov$MES &lt;- as.character(lista_dataframes_mes$nov$MES)\nlista_dataframes_mes$dic$MES &lt;- as.character(lista_dataframes_mes$dic$MES)\n\n# Unir todos los dataframes de la lista\n# bind_rows es robusto y manejará columnas que no estén en todos los dfs (llenando con NA)\ndatos_R &lt;- bind_rows(lista_dataframes_mes, .id = \"fuente_mes\")\n# .id = \"fuente_mes\" añadirá una columna indicando de qué archivo (mes) vino cada fila.\n\ndatos_bogota &lt;- datos_R %&gt;% filter(DPTO == \"11\") %&gt;%\n   select(fuente_mes,  DIRECTORIO,   SECUENCIA_P, CLASE,\n    DPTO, P4030S1A1,\n    P4000, P5000, P5010, P5090, P5100, P5110, P5130,\n    P5140,  P6008, FEX_C18) %&gt;%\n  rename(estrato = P4030S1A1, tipo_vivienda = P4000, cuartos = P5000, dormitorios = P5010,\n    tenencia = P5090, cuota = P5100, valor_venderia = P5110,\n    estima_arriendo = P5130, arriendo = P5140, total_personas_hogar = P6008\n  ) %&gt;% mutate(FEX_C18 = FEX_C18  / 12)\n\n\n\n\n# Nombres abreviados de los meses (clave para construir nombres de archivo)\nmeses_abreviados_py = [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\",\n                       \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n\n# Diccionario para almacenar los DataFrames mensuales\ndict_dataframes_mes_py = {}\n\n# Leer archivos mensuales\nfor mes in meses_abreviados_py:\n    nombre_archivo = f\"Datos del hogar y la vivienda_{mes}.CSV\"\n    print(f\"Intentando leer archivo: {nombre_archivo}\")\n\n    if os.path.exists(nombre_archivo):\n        try:\n            df_mes = pd.read_csv(nombre_archivo, sep=';', decimal=',',  encoding='latin1')\n            dict_dataframes_mes_py[mes] = df_mes\n            print(f\"Archivo {nombre_archivo} leído correctamente.\")\n        except Exception as e:\n            print(f\"Advertencia: No se pudo leer el archivo {nombre_archivo} - {e}\")\n    else:\n        print(f\"Advertencia: El archivo {nombre_archivo} no fue encontrado.\")\n\nIntentando leer archivo: Datos del hogar y la vivienda_ene.CSV\nArchivo Datos del hogar y la vivienda_ene.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_feb.CSV\nArchivo Datos del hogar y la vivienda_feb.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_mar.CSV\nArchivo Datos del hogar y la vivienda_mar.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_abr.CSV\nArchivo Datos del hogar y la vivienda_abr.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_may.CSV\nArchivo Datos del hogar y la vivienda_may.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_jun.CSV\nArchivo Datos del hogar y la vivienda_jun.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_jul.CSV\nArchivo Datos del hogar y la vivienda_jul.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_ago.CSV\nArchivo Datos del hogar y la vivienda_ago.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_sep.CSV\nArchivo Datos del hogar y la vivienda_sep.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_oct.CSV\nArchivo Datos del hogar y la vivienda_oct.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_nov.CSV\nArchivo Datos del hogar y la vivienda_nov.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_dic.CSV\nArchivo Datos del hogar y la vivienda_dic.CSV leído correctamente.\n\n# Agregar columna de origen y unir todos los DataFrames leídos\nlista_para_concatenar = [\n    df.assign(fuente_mes=mes) for mes, df in dict_dataframes_mes_py.items()\n]\n\n# Concatenar en un solo DataFrame si hay datos válidos\nif lista_para_concatenar:\n    datos = pd.concat(lista_para_concatenar, ignore_index=True)\n    print(f\"{len(lista_para_concatenar)} archivos fueron unidos en un solo DataFrame.\")\nelse:\n    print(\"No se encontraron archivos válidos para unir.\")\n\n12 archivos fueron unidos en un solo DataFrame.\n\n\ndatos_bogota = datos[datos[\"DPTO\"] == 11].copy()  # Use .copy() to avoid SettingWithCopyWarning\ndatos_bogota[\"FEX_C18\"] = pd.to_numeric(datos_bogota[\"FEX_C18\"], errors=\"coerce\")\n\ndatos_bogota[\"FEX_C18\"] = datos_bogota[\"FEX_C18\"] / 12\n\n\n# Mantener solo las columnas necesarias\ndatos_bogota = datos_bogota[[ \"fuente_mes\", \"DIRECTORIO\", \"SECUENCIA_P\",\n    \"CLASE\",  \"DPTO\", \"P4030S1A1\", \"P4000\", \"P5000\", \"P5010\",  \"P5090\",\n    \"P5100\",  \"P5110\", \"P5130\", \"P5140\",  \"P6008\", \"FEX_C18\"]]\n\n# Renombrar columnas\ndatos_bogota = datos_bogota.rename(columns={\"P4030S1A1\": \"estrato\",\n    \"P4000\": \"tipo_vivienda\", \"P5000\": \"cuartos\",   \"P5010\": \"dormitorios\",\n    \"P5090\": \"tenencia\", \"P5100\": \"cuota\",   \"P5110\": \"valor_venderia\",\n    \"P5130\": \"estima_arriendo\", \"P5140\": \"arriendo\",   \"P6008\": \"total_personas_hogar\"})\n\n\n# Nombres abreviados de los meses (clave para construir nombres de archivo)\nmeses_abreviados_py = [\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\",\n                       \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\"]\n\n# Diccionario para almacenar los DataFrames mensuales\ndict_dataframes_mes_py = {}\n\n# Leer archivos mensuales\nfor mes in meses_abreviados_py:\n    nombre_archivo = f\"Datos del hogar y la vivienda_{mes}.CSV\"\n    print(f\"Intentando leer archivo: {nombre_archivo}\")\n\n    if os.path.exists(nombre_archivo):\n        try:\n            df_mes = pd.read_csv(nombre_archivo, sep=';', decimal=',',  encoding='latin1')\n            dict_dataframes_mes_py[mes] = df_mes\n            print(f\"Archivo {nombre_archivo} leído correctamente.\")\n        except Exception as e:\n            print(f\"Advertencia: No se pudo leer el archivo {nombre_archivo} - {e}\")\n    else:\n        print(f\"Advertencia: El archivo {nombre_archivo} no fue encontrado.\")\n\nIntentando leer archivo: Datos del hogar y la vivienda_ene.CSV\nArchivo Datos del hogar y la vivienda_ene.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_feb.CSV\nArchivo Datos del hogar y la vivienda_feb.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_mar.CSV\nArchivo Datos del hogar y la vivienda_mar.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_abr.CSV\nArchivo Datos del hogar y la vivienda_abr.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_may.CSV\nArchivo Datos del hogar y la vivienda_may.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_jun.CSV\nArchivo Datos del hogar y la vivienda_jun.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_jul.CSV\nArchivo Datos del hogar y la vivienda_jul.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_ago.CSV\nArchivo Datos del hogar y la vivienda_ago.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_sep.CSV\nArchivo Datos del hogar y la vivienda_sep.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_oct.CSV\nArchivo Datos del hogar y la vivienda_oct.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_nov.CSV\nArchivo Datos del hogar y la vivienda_nov.CSV leído correctamente.\nIntentando leer archivo: Datos del hogar y la vivienda_dic.CSV\nArchivo Datos del hogar y la vivienda_dic.CSV leído correctamente.\n\n# Agregar columna de origen y unir todos los DataFrames leídos\nlista_para_concatenar = [\n    df.assign(fuente_mes=mes) for mes, df in dict_dataframes_mes_py.items()\n]\n\n# Concatenar en un solo DataFrame si hay datos válidos\nif lista_para_concatenar:\n    datos = pd.concat(lista_para_concatenar, ignore_index=True)\n    print(f\"{len(lista_para_concatenar)} archivos fueron unidos en un solo DataFrame.\")\nelse:\n    print(\"No se encontraron archivos válidos para unir.\")\n\n12 archivos fueron unidos en un solo DataFrame.\n\n\ndatos_bogota = datos[datos[\"DPTO\"] == 11].copy()  # Use .copy() to avoid SettingWithCopyWarning\ndatos_bogota[\"FEX_C18\"] = pd.to_numeric(datos_bogota[\"FEX_C18\"], errors=\"coerce\")\n\ndatos_bogota[\"FEX_C18\"] = datos_bogota[\"FEX_C18\"] / 12\n\n\n# Mantener solo las columnas necesarias\ndatos_bogota = datos_bogota[[ \"fuente_mes\", \"DIRECTORIO\", \"SECUENCIA_P\",\n    \"CLASE\",  \"DPTO\", \"P4030S1A1\", \"P4000\", \"P5000\", \"P5010\",  \"P5090\",\n    \"P5100\",  \"P5110\", \"P5130\", \"P5140\",  \"P6008\", \"FEX_C18\"]]\n\n# Renombrar columnas\ndatos_bogota = datos_bogota.rename(columns={\"P4030S1A1\": \"estrato\",\n    \"P4000\": \"tipo_vivienda\", \"P5000\": \"cuartos\",   \"P5010\": \"dormitorios\",\n    \"P5090\": \"tenencia\", \"P5100\": \"cuota\",   \"P5110\": \"valor_venderia\",\n    \"P5130\": \"estima_arriendo\", \"P5140\": \"arriendo\",   \"P6008\": \"total_personas_hogar\"})"
  },
  {
    "objectID": "clase1_diplomado.html#cálculo-de-tablas-de-frecuencias-univariadas",
    "href": "clase1_diplomado.html#cálculo-de-tablas-de-frecuencias-univariadas",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Cálculo de tablas de frecuencias univariadas",
    "text": "Cálculo de tablas de frecuencias univariadas\nEn primer lugar creamos variables categóricas (etiquetas) a las variables de interés para poder entender más fácil las variables de tipo categórico:\n\nRPython\n\n\n\nlibrary(dplyr)\ndatos_bogota$tenencia &lt;- factor(datos_bogota$tenencia,\n                             labels = c(\"Propia, totalmente pagada\", \"Propia, la están pagando\",\n\"En arriendo o subarriendo\", \"En usufructo\", \"Posesión sin título\", \"Propiedad colectiva\", \"Otra\"))\n\ndatos_bogota$estrato &lt;- factor(datos_bogota$estrato,\n                             labels = c(\"Conexión pirata\", paste0(\"Estrato \", 1:6), \n                                        \"No sabe o cuenta con planta eléctrica\"))\n\n\n\n\nlabels_tenencia = [\"Propia, totalmente pagada\",    \"Propia, la están pagando\",\n    \"En arriendo o subarriendo\",  \"En usufructo\", \"Posesión sin título\",\n    \"Propiedad colectiva\",  \"Otra\"]\n\n# 2. Convert `P5090` to a categorical variable with labels\ndatos_bogota[\"tenencia\"] = pd.Categorical(\n    datos_bogota[\"tenencia\"], categories=range(1, 8),  ordered=False)\ndatos_bogota[\"tenencia\"] = datos_bogota[\"tenencia\"].cat.rename_categories(labels_tenencia)\n\n\nlabels_estrato = [\"Conexión pirata\"] + [f\"Estrato {i}\" for i in range(1, 7)] + [\"No sabe o cuenta con planta eléctrica\"]\ndatos_bogota[\"estrato\"] = pd.Categorical(\n    datos_bogota[\"estrato\"], categories=list(range(0, 7)) + [9], ordered=False)\ndatos_bogota[\"estrato\"] = datos_bogota[\"estrato\"].cat.rename_categories(labels_estrato)"
  },
  {
    "objectID": "clase1_diplomado.html#construir-la-tablas-de-frecuencias-univariadas",
    "href": "clase1_diplomado.html#construir-la-tablas-de-frecuencias-univariadas",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Construir la tablas de frecuencias univariadas",
    "text": "Construir la tablas de frecuencias univariadas\nVamos a crear una tabla de frecuencia de la tenencia de vivienda, puede calcularse con R y python de manera rápida\n\nRPython\n\n\n\ntable(datos_bogota$tenencia)\n\n\nPropia, totalmente pagada  Propia, la están pagando En arriendo o subarriendo \n                     3146                       849                      5017 \n             En usufructo       Posesión sin título       Propiedad colectiva \n                      849                        41                       110 \n                     Otra \n                        4 \n\n\n\nprop.table(table(datos_bogota$tenencia)) * 100\n\n\nPropia, totalmente pagada  Propia, la están pagando En arriendo o subarriendo \n               31.4097444                 8.4764377                50.0898562 \n             En usufructo       Posesión sin título       Propiedad colectiva \n                8.4764377                 0.4093450                 1.0982428 \n                     Otra \n                0.0399361 \n\n\nPero podemos calcular una tabla más estructurada:\n\ntablaFrec_tenencia &lt;- datos_bogota %&gt;% group_by(tenencia) %&gt;% summarise(cuenta = n()) %&gt;% \n  arrange(desc(cuenta)) %&gt;% mutate(frec_relativa = round(cuenta / sum(cuenta) * 100, 1), \n  frec_relativaAcum = cumsum(frec_relativa))\n\nEjercicio hacerlo para el estrato socioeconómico.\n\n\n\ndatos_bogota['tenencia'].value_counts()\n\ntenencia\nEn arriendo o subarriendo    5017\nPropia, totalmente pagada    3146\nPropia, la están pagando      849\nEn usufructo                  849\nPropiedad colectiva           110\nPosesión sin título            41\nOtra                            4\nName: count, dtype: int64\n\n\n\n# Frecuencia relativa en porcentaje (equivalente a prop.table(table(datos$x)) * 100)\ndatos_bogota['tenencia'].value_counts(normalize=True) * 100\n\ntenencia\nEn arriendo o subarriendo    50.089856\nPropia, totalmente pagada    31.409744\nPropia, la están pagando      8.476438\nEn usufructo                  8.476438\nPropiedad colectiva           1.098243\nPosesión sin título           0.409345\nOtra                          0.039936\nName: proportion, dtype: float64\n\n\nLo haremos más estructurado\n\ntablaFrec_tenencia = (\n    datos_bogota\n    .groupby(\"tenencia\")\n    .size()  # counts per group\n    .reset_index(name=\"cuenta\")\n    .sort_values(\"cuenta\", ascending=False)\n)\n\n&lt;string&gt;:3: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning.\n\n\ntablaFrec_tenencia[\"frec_relativa\"] = (\n    round(tablaFrec_tenencia[\"cuenta\"] / tablaFrec_tenencia[\"cuenta\"].sum() * 100, 1)\n)\ntablaFrec_tenencia[\"frec_relativaAcum\"] = tablaFrec_tenencia[\"frec_relativa\"].cumsum()"
  },
  {
    "objectID": "clase1_diplomado.html#perfiles-filas-y-columna",
    "href": "clase1_diplomado.html#perfiles-filas-y-columna",
    "title": "Diplomado: Métodos Estadísticos para el Análisis de Datos",
    "section": "Perfiles filas y columna",
    "text": "Perfiles filas y columna\nAquí explicamos cómo se calculan los perfiles fila y columna.\n\nTabla de Contingencia Base\nSea una tabla de contingencia para dos variables categóricas, \\(X\\) (con \\(I\\) categorías) e \\(Y\\) (con \\(J\\) categorías). Denotamos \\(n_{ij}\\) como la frecuencia observada.\n\\[\n\\begin{array}{c|cccc|c}\n& Y_1 & Y_2 & \\dots & Y_J & \\text{Total Fila} \\\\\n\\hline\nX_1 & n_{11} & n_{12} & \\dots & n_{1J} & n_{1.} \\\\\nX_2 & n_{21} & n_{22} & \\dots & n_{2J} & n_{2.} \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\nX_I & n_{I1} & n_{I2} & \\dots & n_{IJ} & n_{I.} \\\\\n\\hline\n\\text{Total Columna} & n_{.1} & n_{.2} & \\dots & n_{.J} & N \\\\\n\\end{array}\n\\]\n\n\nPerfil Fila\nEl perfil fila para la celda \\((i,j)\\) es: \\[\n\\text{Perfil Fila (\\%)}_{ij} = \\left( \\frac{n_{ij}}{n_{i.}} \\right) \\times 100\\%\n\\] donde \\(n_{i.} = \\sum_{k=1}^{J} n_{ik}\\) es el total de la fila \\(i\\).\n\n\nPerfil Columna\nEl perfil columna para la celda \\((i,j)\\) es: \\[\n\\text{Perfil Columna (\\%)}_{ij} = \\left( \\frac{n_{ij}}{n_{.j}} \\right) \\times 100\\%\n\\] donde \\(n_{.j} = \\sum_{k=1}^{I} n_{kj}\\) es el total de la columna \\(j\\).\nQueremos analizar la tenencia de vivienda por estrato:\n\nRPython\n\n\n\ntf_tenenciaEstrato &lt;- table(datos_bogota$estrato, datos_bogota$tenencia)\n\nEs interesante analizar el perfil fila, es decir de cada estrato cuantas hogares tienen vivienda propia en arriendo, etc, el perfil fila:\n\npf_tenenciaEstrato &lt;- round(prop.table(table(datos_bogota$estrato, datos_bogota$tenencia), 1) * 100, 1)\ntf_tenenciaEstrato\n\n                                       \n                                        Propia, totalmente pagada\n  Conexión pirata                                               2\n  Estrato 1                                                   247\n  Estrato 2                                                  1024\n  Estrato 3                                                  1136\n  Estrato 4                                                   438\n  Estrato 5                                                   165\n  Estrato 6                                                   134\n  No sabe o cuenta con planta eléctrica                         0\n                                       \n                                        Propia, la están pagando\n  Conexión pirata                                              1\n  Estrato 1                                                   58\n  Estrato 2                                                  300\n  Estrato 3                                                  277\n  Estrato 4                                                  134\n  Estrato 5                                                   49\n  Estrato 6                                                   30\n  No sabe o cuenta con planta eléctrica                        0\n                                       \n                                        En arriendo o subarriendo En usufructo\n  Conexión pirata                                              11            1\n  Estrato 1                                                   425           93\n  Estrato 2                                                  2166          342\n  Estrato 3                                                  1781          293\n  Estrato 4                                                   441           75\n  Estrato 5                                                   105           29\n  Estrato 6                                                    88           15\n  No sabe o cuenta con planta eléctrica                         0            1\n                                       \n                                        Posesión sin título Propiedad colectiva\n  Conexión pirata                                        22                   2\n  Estrato 1                                               7                   9\n  Estrato 2                                               8                  56\n  Estrato 3                                               3                  32\n  Estrato 4                                               0                   5\n  Estrato 5                                               0                   2\n  Estrato 6                                               0                   4\n  No sabe o cuenta con planta eléctrica                   0                   0\n                                       \n                                        Otra\n  Conexión pirata                          1\n  Estrato 1                                1\n  Estrato 2                                2\n  Estrato 3                                0\n  Estrato 4                                0\n  Estrato 5                                0\n  Estrato 6                                0\n  No sabe o cuenta con planta eléctrica    0\n\n\n\n\n\npf_tenenciaEstrato = pd.crosstab(\n    datos_bogota[\"estrato\"],  datos_bogota[\"tenencia\"],\n    normalize='index') * 100  # Redondea primero para evitar errores de punto flotante\n\npf_tenenciaEstrato = pf_tenenciaEstrato.round(1)  # Redondeo final como en R\n\n\n\n\n\nRPython\n\n\n\npc_tenenciaEstrato &lt;- round(prop.table(table(datos_bogota$estrato, datos_bogota$tenencia), 2) * 100, 1)\ntf_tenenciaEstrato\n\n                                       \n                                        Propia, totalmente pagada\n  Conexión pirata                                               2\n  Estrato 1                                                   247\n  Estrato 2                                                  1024\n  Estrato 3                                                  1136\n  Estrato 4                                                   438\n  Estrato 5                                                   165\n  Estrato 6                                                   134\n  No sabe o cuenta con planta eléctrica                         0\n                                       \n                                        Propia, la están pagando\n  Conexión pirata                                              1\n  Estrato 1                                                   58\n  Estrato 2                                                  300\n  Estrato 3                                                  277\n  Estrato 4                                                  134\n  Estrato 5                                                   49\n  Estrato 6                                                   30\n  No sabe o cuenta con planta eléctrica                        0\n                                       \n                                        En arriendo o subarriendo En usufructo\n  Conexión pirata                                              11            1\n  Estrato 1                                                   425           93\n  Estrato 2                                                  2166          342\n  Estrato 3                                                  1781          293\n  Estrato 4                                                   441           75\n  Estrato 5                                                   105           29\n  Estrato 6                                                    88           15\n  No sabe o cuenta con planta eléctrica                         0            1\n                                       \n                                        Posesión sin título Propiedad colectiva\n  Conexión pirata                                        22                   2\n  Estrato 1                                               7                   9\n  Estrato 2                                               8                  56\n  Estrato 3                                               3                  32\n  Estrato 4                                               0                   5\n  Estrato 5                                               0                   2\n  Estrato 6                                               0                   4\n  No sabe o cuenta con planta eléctrica                   0                   0\n                                       \n                                        Otra\n  Conexión pirata                          1\n  Estrato 1                                1\n  Estrato 2                                2\n  Estrato 3                                0\n  Estrato 4                                0\n  Estrato 5                                0\n  Estrato 6                                0\n  No sabe o cuenta con planta eléctrica    0\n\n\n\n\n\npc_tenenciaEstrato = pd.crosstab(\n    datos_bogota[\"estrato\"],  datos_bogota[\"tenencia\"],\n    normalize='columns') * 100  # Redondea primero para evitar errores de punto flotante\n\npc_tenenciaEstrato = pc_tenenciaEstrato.round(1)   # Redondeo final como en R\n\n\n\n\nAhora algunas opciones más sofisticadas en R:\n\nR\n\n\n\ndatos_bogota %&gt;%\n  tabyl(estrato, tenencia) %&gt;%\n  adorn_totals(\"row\") %&gt;%\n  adorn_totals(\"col\") %&gt;%\n  adorn_percentages(\"row\") %&gt;%\n  adorn_pct_formatting(digits = 1) %&gt;%\n  adorn_ns(position = \"front\")\n\n                               estrato Propia, totalmente pagada\n                       Conexión pirata                 2  (5.0%)\n                             Estrato 1               247 (29.4%)\n                             Estrato 2             1,024 (26.3%)\n                             Estrato 3             1,136 (32.3%)\n                             Estrato 4               438 (40.1%)\n                             Estrato 5               165 (47.1%)\n                             Estrato 6               134 (49.4%)\n No sabe o cuenta con planta eléctrica                 0  (0.0%)\n                                  &lt;NA&gt;                 0  (0.0%)\n                                 Total             3,146 (31.4%)\n Propia, la están pagando En arriendo o subarriendo En usufructo\n                1  (2.5%)                11 (27.5%)   1   (2.5%)\n               58  (6.9%)               425 (50.6%)  93  (11.1%)\n              300  (7.7%)             2,166 (55.6%) 342   (8.8%)\n              277  (7.9%)             1,781 (50.6%) 293   (8.3%)\n              134 (12.3%)               441 (40.3%)  75   (6.9%)\n               49 (14.0%)               105 (30.0%)  29   (8.3%)\n               30 (11.1%)                88 (32.5%)  15   (5.5%)\n                0  (0.0%)                 0  (0.0%)   1 (100.0%)\n                0  (0.0%)                 0  (0.0%)   0   (0.0%)\n              849  (8.5%)             5,017 (50.1%) 849   (8.5%)\n Posesión sin título Propiedad colectiva     Otra           Total\n         22  (55.0%)            2 (5.0%) 1 (2.5%)     40 (100.0%)\n          7   (0.8%)            9 (1.1%) 1 (0.1%)    840 (100.0%)\n          8   (0.2%)           56 (1.4%) 2 (0.1%)  3,898 (100.0%)\n          3   (0.1%)           32 (0.9%) 0 (0.0%)  3,522 (100.0%)\n          0   (0.0%)            5 (0.5%) 0 (0.0%)  1,093 (100.0%)\n          0   (0.0%)            2 (0.6%) 0 (0.0%)    350 (100.0%)\n          0   (0.0%)            4 (1.5%) 0 (0.0%)    271 (100.0%)\n          0   (0.0%)            0 (0.0%) 0 (0.0%)      1 (100.0%)\n          1 (100.0%)            0 (0.0%) 0 (0.0%)      1 (100.0%)\n         41   (0.4%)          110 (1.1%) 4 (0.0%) 10,016 (100.0%)\n\n\n\ntab_xtab(datos_bogota$estrato, datos_bogota$tenencia,\n         show.row.prc = TRUE,     # % por fila\n         show.col.prc = TRUE,     # % por columna\n         show.cell.prc = TRUE,    # % respecto al total general\n         show.summary = TRUE, encoding = \"UTF-8\")     # totales fila y columna\n\n\n \n estrato\n tenencia\n Total\n \n \n\n Propia, totalmentepagada\n Propia, la estánpagando\n En arriendo osubarriendo\n En usufructo\n Posesión sin título\n Propiedad colectiva\n Otra\n \n \n \nConexión pirata\n25 %0.1 %0 %\n12.5 %0.1 %0 %\n1127.5 %0.2 %0.1 %\n12.5 %0.1 %0 %\n2255 %55 %0.2 %\n25 %1.8 %0 %\n12.5 %25 %0 %\n40100 %0.4 %0.3 % \n\n \n \nEstrato 1\n24729.4 %7.9 %2.5 %\n586.9 %6.8 %0.6 %\n42550.6 %8.5 %4.2 %\n9311.1 %11 %0.9 %\n70.8 %17.5 %0.1 %\n91.1 %8.2 %0.1 %\n10.1 %25 %0 %\n840100 %8.4 %8.4 % \n\n \n \nEstrato 2\n102426.3 %32.5 %10.2 %\n3007.7 %35.3 %3 %\n216655.6 %43.2 %21.6 %\n3428.8 %40.3 %3.4 %\n80.2 %20 %0.1 %\n561.4 %50.9 %0.6 %\n20.1 %50 %0 %\n3898100 %38.9 %38.9 % \n\n \n \nEstrato 3\n113632.3 %36.1 %11.3 %\n2777.9 %32.6 %2.8 %\n178150.6 %35.5 %17.8 %\n2938.3 %34.5 %2.9 %\n30.1 %7.5 %0 %\n320.9 %29.1 %0.3 %\n00 %0 %0 %\n3522100 %35.2 %35.1 % \n\n \n \nEstrato 4\n43840.1 %13.9 %4.4 %\n13412.3 %15.8 %1.3 %\n44140.3 %8.8 %4.4 %\n756.9 %8.8 %0.7 %\n00 %0 %0 %\n50.5 %4.5 %0 %\n00 %0 %0 %\n1093100 %10.9 %10.8 % \n\n \n \nEstrato 5\n16547.1 %5.2 %1.6 %\n4914 %5.8 %0.5 %\n10530 %2.1 %1 %\n298.3 %3.4 %0.3 %\n00 %0 %0 %\n20.6 %1.8 %0 %\n00 %0 %0 %\n350100 %3.5 %3.4 % \n\n \n \nEstrato 6\n13449.4 %4.3 %1.3 %\n3011.1 %3.5 %0.3 %\n8832.5 %1.8 %0.9 %\n155.5 %1.8 %0.1 %\n00 %0 %0 %\n41.5 %3.6 %0 %\n00 %0 %0 %\n271100 %2.7 %2.6 % \n\n \n \nNo sabe o cuenta conplanta eléctrica\n00 %0 %0 %\n00 %0 %0 %\n00 %0 %0 %\n1100 %0.1 %0 %\n00 %0 %0 %\n00 %0 %0 %\n00 %0 %0 %\n1100 %0 %0 % \n\n \n \nTotal\n314631.4 %100 %31.4 %\n8498.5 %100 %8.5 %\n501750.1 %100 %50.1 %\n8498.5 %100 %8.5 %\n400.4 %100 %0.4 %\n1101.1 %100 %1.1 %\n40 %100 %0 %\n10015100 %100 %100 % \n\nχ2=3375.233 · df=42 · Cramer's V=0.237 · Fisher's p=0.000"
  }
]